{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf460
{\fonttbl\f0\fnil\fcharset0 LucidaGrande;\f1\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;}
\vieww12240\viewh15840\viewkind1
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\b\fs48 \cf0 Intro
\fs24 \
\
Why use Python for games?
\b0 \
The same reason you use Python for anything else. It's easy, it makes sense, and there are great libraries available.\
\

\b Speaking of libraries, what's available?
\b0 \
 * PyGame\
 * pyglet\
 * Panda3D\
\

\b Which one should I use?\

\b0 My personal opinion is that pyglet is the cleanest and fastest, but PyGame has also been used to do some cool things. Panda3D is more sophisticated, geared toward 3D, and has a much higher learning curve. I won't go into specifics for now.\
\
To get you familiar with pyglet, I'll walk you through the process of creating a simple version of the classic game Asteroids.\
\

\b\fs48 Part 1: Basic Graphics
\b0\fs24 \
\
The first version of our Asteroids clone will simply show a score of zero, a label showing the name of the program, three randomly placed asteroids, and the player's ship. Nothing will move.
\b\fs48 \

\fs36 \
Setting Up
\fs24 \
\
Installing Pyglet\

\b0 Download pyglet from http://pyglet.org/download.html and choose the distribution for your platform. The process is different for each platform, but simple on all of them, since pyglet has no external dependencies.
\b \
\
Setting Up the Files\

\b0 Since I wrote this example in stages, I'm putting the folder with the images, called 'resources,' outside the example folders. Each example folder contains a Python file called 
\f1\fs20 asteroid.py
\f0\fs24  which runs the game, as well as a 
\f1\fs20 game
\f0\fs24  module which contains most of the functionality.
\b \
\
Getting a Window\

\b0 To set up a window, simply import pyglet, create a new instance of 
\f1\fs20 pyglet.window.Window
\f0\fs24 , and call 
\f1\fs20 pyglet.app.run()
\f0\fs24 .\
\

\f1\fs20 import pyglet\
game_window = pyglet.window.Window(800, 600)\
\
if __name__ == '__main__':\
	pyglet.app.run()
\f0\fs24 \
\
When you run the code above, you should see a window full of junk that goes away when you press Esc.\
\

\b Loading and Displaying an Image
\b0 \
Let's create a separate submodule of 
\f1\fs20 game
\f0\fs24  to hold resources, calling it 
\f1\fs20 resources.py
\f0\fs24 .\
\
Since our images reside in a directory other than the example's root directory, we need to tell pyglet where to find them:\
\

\f1\fs20 import pyglet\
pyglet.resource.path = ['../resources']\
pyglet.resource.reindex()\

\f0\fs24 \
Now we can easily load the images:\
\

\f1\fs20 player_image = pyglet.resource.image("player.png")\
bullet_image = pyglet.resource.image("bullet.png")\
asteroid_image = pyglet.resource.image("asteroid.png")\

\f0\fs24 \

\b Centering the Images
\b0 \
Pyglet will draw all images from their lower left corner, which we don't want for our images, which need to rotate around their centers. All we have to do to fix this problem is set their anchor points:\
\

\f1\fs20 def center_image(image):\
    """Sets an image's anchor point to its center"""\
    image.anchor_x = image.width/2\
    image.anchor_y = image.height/2
\f0\fs24 \
\
Now we can just call 
\f1\fs20 center_image()
\f0\fs24  on all our loaded images:\
\

\f1\fs20 center_image(player_image)\
center_image(bullet_image)\
center_image(asteroid_image)
\f0\fs24 \
\
To access these images from 
\f1\fs20 asteroids.py
\f0\fs24 , we need to use something like 
\f1\fs20 from game import resources
\f0\fs24 .
\b\fs48 \

\fs36 \
Initializing Objects
\b0\fs24 \
\

\b Making the Labels
\b0 \
It's easy to make a text label in pyglet:\
\

\f1\fs20 score_label = pyglet.text.Label(text="Score: 0", x=10, y=575)\
level_label = pyglet.text.Label(text="Version 1: Static Graphics", \
                                x=400, y=575, anchor_x='center')
\f0\fs24 \
\
Note that the second label is centered using the anchor_x attribute.\
\

\b Making the Player and Asteroid Sprites\

\b0 The player should be an instance or subclass of 
\f1\fs20 pyglet.sprite.Sprite
\f0\fs24 , like so:\
\

\f1\fs20 player_ship = pyglet.sprite.Sprite(img=resources.player_image, x=400, y=300)
\f0\fs24 \
\
Loading the asteroids is a little more complicated, since we'll need to place more than one at random locations that don't immediately collide with the player. Let's put the loading code in a new 
\f1\fs20 game
\f0\fs24  submodule called 
\f1\fs20 load.py
\f0\fs24 :\
\

\f1\fs20 def asteroids(num_asteroids):\
    asteroids = []\
    for i in range(num_asteroids):\
        asteroid_x = random.randint(0, 800)\
        asteroid_y = random.randint(0, 600)\
        new_asteroid = pyglet.sprite.Sprite(img=resources.asteroid_image, \
                                            x=asteroid_x, y=asteroid_y)\
        new_asteroid.rotation = random.randint(0, 360)\
        asteroids.append(new_asteroid)\
    return asteroids
\f0\fs24 \
\
All we are doing here is making a few new sprites with random positions. There's still a problem, though: an asteroid might randomly be placed exactly where the player is, causing immediate death. To fix this issue, we'll need to be able to tell how far away new asteroids are from the player. Here is a simple function to calculate that distance, which requires you to import the 
\f1\fs20 math
\f0\fs24  module:\
\

\f1\fs20 def distance(point_1=(0, 0), point_2=(0, 0)):\
    """Returns the distance between two points"""\
    return math.sqrt((point_1[0]-point_2[0])**2+(point_1[1]-point_2[1])**2)
\f0\fs24 \
\
To check new asteroids agains the player's position, we need to pass the player's position into the 
\f1\fs20 asteroids()
\f0\fs24  function and keep regenerating new coordinates until the asteroid is far enough away. Here is the complete function, which requires you to import the 
\f1\fs20 random
\f0\fs24  module:\
\

\f1\fs20 def asteroids(num_asteroids, player_position):\
    asteroids = []\
    for i in range(num_asteroids):\
        asteroid_x, asteroid_y = player_position\
        while distance((asteroid_x, asteroid_y), player_position) < 100:\
            asteroid_x = random.randint(0, 800)\
            asteroid_y = random.randint(0, 600)\
        new_asteroid = pyglet.sprite.Sprite(img=resources.asteroid_image, \
                                            x=asteroid_x, y=asteroid_y)\
        new_asteroid.rotation = random.randint(0, 360)\
        asteroids.append(new_asteroid)\
    return asteroids
\f0\fs24 \
\
For each asteroid, it chooses random positions until it finds one away from the player, creates the sprite, and gives it a random rotation. Each asteroid is appended to a list, which is returned.\
\
To access this function from your main loading code, you need to import the 
\f1\fs20 load
\f0\fs24  module with 
\f1\fs20 from game import load
\f0\fs24 . Now you can load three asteroids like this:\
\

\f1\fs20 asteroids = load.asteroids(3, (player_ship.x, player_ship.y))
\f0\fs24 \
\
The 
\f1\fs20 asteroids
\f0\fs24  variable now contains a list of sprites.
\b\fs48 \

\fs36 \
Drawing the Objects
\b0\fs24 \
\

\b Writing the on_draw() Event Handler
\b0 \
We want pyglet to call a custom function whenever the window is drawn. To make that happen, we need to either subclass 
\f1\fs20 Window
\f0\fs24 , or use the 
\f1\fs20 @Window.event
\f0\fs24  decorator:\
\

\f1\fs20 @game_window.event\
def on_draw():\
	# draw things here\

\f0\fs24 \
Before we draw any objects we should clear the screen. After that, we can simply call each object's 
\f1\fs20 draw()
\f0\fs24  function.\
\

\f1\fs20 @game_window.event\
def on_draw():\
    game_window.clear()\
    \
    player_ship.draw()\
    for asteroid in asteroids:\
        asteroid.draw()\
    \
    level_label.draw()\
    score_label.draw()
\f0\fs24 \
\
The 
\f1\fs20 @game_window.event
\f0\fs24  decorator lets the Window instance know that 
\f1\fs20 on_draw()
\f0\fs24  is an event handler. The on_draw event is fired whenever - you guessed it - the window needs to be redrawn. Other events include on_mouse_press and on_key_press.\
\

\b What You Should See
\b0 \
Now when you run 
\f1\fs20 asteroids.py
\f0\fs24 , you should get a window with a score of zero in the upper left corner, a centered label reading "Version 1: Static Graphics" at the top of the screen, three randomly placed asteroids, and a blue ship centered in the middle.\
\

\b\fs48 Part 2: Basic Motion
\fs24 \
\

\b0 In the second version of the example, we'll introduce a simpler, faster way to draw all of the game objects, as well as add row of icons indicating the number of lives left. We'll also write some code to make the player and the asteroids.
\b\fs48 \

\fs36 \
More Graphics
\fs24 \
\
Drawing with Batches\

\b0 Calling each object's draw() method manually can become cumbersome and tedious if there are many different kinds of objects. Graphics batches simplify drawing by letting you draw all your objects with a single function call. All you need to do is create a batch, pass it into each object you want to draw, and call the batch's 
\f1\fs20 draw()
\f0\fs24  method.\
\
To create a new batch, simply call 
\f1\fs20 pyglet.graphics.Batch()
\f0\fs24 :\
\

\f1\fs20 main_batch = pyglet.graphics.Batch()
\f0\fs24 \
\
To make an object a member of a batch, just pass the batch into its constructor as the 
\f1\fs20 batch
\f0\fs24  keyword argument:\
\

\f1\fs20 score_label = pyglet.text.Label(text="Score: 0", x=10, y=575, batch=main_batch)
\f0\fs24 \
\
Add the 
\f1\fs20 batch
\f0\fs24  keyword argument to each graphical object created in 
\f1\fs20 asteroids.py
\f0\fs24 .\
\
To use the batch with the asteroid sprites, we'll need to pass the batch into the 
\f1\fs20 game.load.asteroid()
\f0\fs24  function, then just add it as a keyword argument to each new sprite:\
\

\f1\fs20 def asteroids(num_asteroids, player_position, batch):\
    ...\
    new_asteroid = pyglet.sprite.Sprite(img=resources.asteroid_image, \
                                            x=asteroid_x, y=asteroid_y,\
                                            batch=batch)\

\f0\fs24 \

\f1\fs20 asteroids = load.asteroids(3, (player_ship.x, player_ship.y), main_batch)
\f0\fs24 \
\
Now you can replace those five lines of 
\f1\fs20 draw()
\f0\fs24  calls with just one:\
\

\f1\fs20 main_batch.draw()
\f0\fs24 \
\
Now when you run 
\f1\fs20 asteroids.py
\f0\fs24 , it should look exactly the same.\
\

\b Displaying Little Ship Icons
\b0 \
To show how many lives the player has left, we'll need to draw a little row of icons in the upper right corner of the screen. Since we'll be making more than one using the same template, let's create a function called 
\f1\fs20 player_lives()
\f0\fs24  in the 
\f1\fs20 load
\f0\fs24  module to generate them.\
\
The icons should look the same as the player's ship. We could create a scaled version using an image editor, or we could just let pyglet do the scaling.\
\
The method for creating the icons is almost exactly the same as the one for creating asteroids. For each icon we just create a sprite, give it a position and scale, and append it to the return list.\
\

\f1\fs20 def player_lives(num_icons, batch=None):\
    player_lives = []\
    for i in range(num_icons):\
        new_sprite = pyglet.sprite.Sprite(img=resources.player_image, \
                                          x=785-i*30, y=585, \
                                          batch=batch)\
        new_sprite.scale = 0.5\
        player_lives.append(new_sprite)\
    return player_lives
\f0\fs24 \
\
The player icon is 50x50 pixels, so half that size will be 25x25. We want to put a little bit of space between each icon, so we create them at 30-pixel intervals starting from the right side of the screen and moving to the left. Note that like the 
\f1\fs20 asteroids()
\f0\fs24  function, 
\f1\fs20 player_lives()
\f0\fs24  takes a 
\f1\fs20 batch
\f0\fs24  argument. A 
\f1\fs20 None
\f0\fs24  value specifies no batch.
\b\fs48 \

\fs36 \
Making Things Move
\b0\fs24 \
\
The game would be pretty boring if nothing on the screen ever moved. To achieve motion, we'll need to write our own set of classes to handle frame-by-frame movement calculations. We'll also need to write a Player class to respond to keyboard input.\
\

\b Creating the Basic Motion Class\

\b0 Since every visible object is represented by at least one Sprite, we may as well make our basic motion class a subclass of 
\f1\fs20 pyglet.sprite.Sprite
\f0\fs24 . Another approach would be to have our class inherit from 
\f1\fs20 object
\f0\fs24  and have a 
\f1\fs20 sprite
\f0\fs24  attribute, but I find that simply subclassing 
\f1\fs20 Sprite
\f0\fs24  provides more convenient notation.\
\
Create a new 
\f1\fs20 game
\f0\fs24  submodule called 
\f1\fs20 physicalobject.py
\f0\fs24  and declare a 
\f1\fs20 PhysicalObject
\f0\fs24  class. The only new attributes we'll be adding will store the object's velocity, so the constructor will be simple.\
\

\f1\fs20 class PhysicalObject(pyglet.sprite.Sprite):\
    \
    def __init__(self, *args, **kwargs):\
        super(PhysicalObject, self).__init__(*args, **kwargs)\
        \
        self.vx, self.vy = 0.0, 0.0
\f0\fs24 \
\
Each object will need to be updated every frame, so let's write an 
\f1\fs20 update()
\f0\fs24  method.\
\

\f1\fs20     def update(self, dt):\
        self.x += self.vx * dt\
        self.y += self.vy * dt
\f0\fs24 \
\
What's 
\f1\fs20 dt
\f0\fs24 ? It's the 
\b time step
\b0 . Game frames are not instantaneous, and they don't always take equal amounts of time. If you've ever tried to play a modern game on an old machine, you know that frame rates can jump all over the place. There are a number of ways to deal with this problem, the simplest one being to just multiply all time-sensitive operations by 
\f1\fs20 dt
\f0\fs24 .\
\
If we give objects a velocity and just let them go, they will fly off the screen before long. Since we're making a version of Asteroids, we would rather they just wrapped around the screen. Here is a simple function that accomplishes this goal:\
\

\f1\fs20     def check_bounds(self):\
        min_x = -self.image.width/2\
        min_y = -self.image.height/2\
        max_x = 800 + self.image.width/2\
        max_y = 600 + self.image.height/2\
        if self.x < min_x:\
            self.x = max_x\
        elif self.x > max_x:\
            self.x = min_x\
        if self.y < min_y:\
            self.y = max_y\
        elif self.y > max_y:\
            self.y = min_y
\f0\fs24 \
\
As you can see, it simply checks to see if objects are no longer visible on the screen, and if so, it moves them to the other side of the screen. To make every PhysicalObject use this behavior, add a call to 
\f1\fs20 self.check_bounds()
\f0\fs24  at the end of 
\f1\fs20 update()
\f0\fs24 .\
\
To make the asteroids use our new motion code, just import the 
\f1\fs20 physicalobject
\f0\fs24  module and change the "new_asteroid = ..." line to create a new 
\f1\fs20 PhysicalObject
\f0\fs24  instead of a 
\f1\fs20 Sprite
\f0\fs24 . You'll also want to give them a random initial velocity. Here is the new, improved 
\f1\fs20 load.asteroids() function
\f0\fs24 :\
\

\f1\fs20 def asteroids(num_asteroids, player_position, batch):\
    ...\
        new_asteroid = physicalobject.PhysicalObject(...)\
        new_asteroid.rotation = random.randint(0, 360)\
        new_asteroid.vx = random.random()*40\
        new_asteroid.vy = random.random()*40\
    ...
\f0\fs24 \
\

\b Writing the Game Update Function
\b0 \
To call each object's 
\f1\fs20 update()
\f0\fs24  method every frame, we first need to have a list of those objects. For now, we can just declare it after setting up all the other objects:\
\

\f1\fs20 game_objects = [player_ship] + asteroids
\f0\fs24 \
\
Now we can write a simple function to iterate over the list:\
\

\f1\fs20 def update(dt):\
    for obj in game_objects:\
        obj.update(dt)
\f0\fs24 \
\
The 
\f1\fs20 update()
\f0\fs24  function takes a 
\f1\fs20 dt
\f0\fs24  parameter because it is still not the source of the actual time step.\
\

\b Calling the Update Function
\b0 \
We need to update the objects at least once per frame. What's a frame? Well, most screens have a maximum refresh rate of 60 hertz. If we set our loop to run at exactly 60 hertz, though, the motion will look a little jerky because it won't match the screen exactly. Instead, we should have it update twice as fast, 120 times per second, to get smooth animation.\
\
Instead of using an actual loop to update the game every frame, we let pyglet call the function at a specified interval, using no more resources than are necessary. The 
\f1\fs20 pyglet.clock
\f0\fs24  module contains a number of ways to call functions periodically or at some specified time in the future. The one we want is 
\f1\fs20 pyglet.clock.schedule_interval()
\f0\fs24 :\
\

\f1\fs20 pyglet.clock.schedule_interval(update, 1/120.0)
\f0\fs24 \
\
Putting this line above 
\f1\fs20 pyglet.app.run()
\f0\fs24  in the 
\f1\fs20 if __name__ == '__main__'
\f0\fs24  block tells pyglet to call 
\f1\fs20 update()
\f0\fs24  120 times per second. Pyglet will pass in the elapsed time, i.e. 
\f1\fs20 dt
\f0\fs24 , as the only parameter.\
\
Now when you run 
\f1\fs20 asteroids.py
\f0\fs24 , you should see your formerly static asteroids drifting serenely across the screen, reappearing on the other side when they slide off the edge.\
\

\b Writing the Player Class
\b0 \
In addition to obeying the basic laws of physics, the player object needs to respond to keyboard input. Start by importing the appropriate modules and subclassing PhysicalObject:\
\
from pyglet.window import key\
import physicalobject, resources\
\

\f1\fs20 class Player(physicalobject.PhysicalObject):\
    \
    def __init__(self, *args, **kwargs):\
        super(Player, self).__init__(img=resources.player_image, \
                                     *args, **kwargs)\

\f0\fs24 \
So far, the only difference between a Player and a PhysicalObject is that a Player will always have the same image. But Player objects need a couple more attributes. Since the ship will always thrust with the same force in whatever direction it points, we'll need to define a constant for the magnitude of that force. We should also define a constant for the ship's rotation speed.\
\

\f1\fs20         self.thrust = 300.0\
        self.rotate_speed = 200.0
\f0\fs24 \
\
Now we need to get the class to respond to user input. Pyglet uses a polling approach to input, sending key press and key release events to registered event handlers. We need to constantly check if a key is down, and one way we can do that is to maintain a dictionary of keys. First, we need to initialize the dictionary in the constructor:\
        \

\f1\fs20         self.keys = dict(left=False, right=False, up=False, down=False)
\f0\fs24 \
\
Then we need to write two methods, 
\f1\fs20 on_key_press()
\f0\fs24  and 
\f1\fs20 on_key_release()
\f0\fs24 . When pyglet checks a new event handler, it looks for these two methods, among others.\
\

\f1\fs20     def on_key_press(self, symbol, modifiers):    \
        if symbol == key.UP:\
            self.keys['up'] = True\
        elif symbol == key.LEFT:\
            self.keys['left'] = True\
        elif symbol == key.RIGHT:\
            self.keys['right'] = True\
\
    def on_key_release(self, symbol, modifiers):\
        if symbol == key.UP:\
            self.keys['up'] = False\
        elif symbol == key.LEFT:\
            self.keys['left'] = False\
        elif symbol == key.RIGHT:\
            self.keys['right'] = False
\f0\fs24 \
\
That looks pretty cumbersome. There's a better way to do it which we'll see later, but for now, this version serves as a good demonstration of pyglet's event system.\
\
The last thing we need to do is write the 
\f1\fs20 update()
\f0\fs24  method. It follows the same behavior as a 
\f1\fs20 PhysicalObject
\f0\fs24  plus a little extra, so we'll need to call the 
\f1\fs20 PhysicalObject
\f0\fs24 's 
\f1\fs20 update()
\f0\fs24  method and then respond to input.\
\

\f1\fs20     def update(self, dt):\
        super(Player, self).update(dt)\
        \
        if self.keys['left']:\
            self.rotation -= self.rotate_speed * dt\
        if self.keys['right']:\
            self.rotation += self.rotate_speed * dt
\f0\fs24 \
\
Pretty simple so far. To rotate the player, we just add the rotation speed to the angle, multiplied by 
\f1\fs20 dt
\f0\fs24  to account for time. Note that 
\f1\fs20 Sprite
\f0\fs24  objects' rotation attributes are in degrees, with clockwise as the positive direction. This means that you need to call 
\f1\fs20 math.degrees()
\f0\fs24  or 
\f1\fs20 math.radians()
\f0\fs24  and make the result negative whenever you use Python's built-in math functions with the 
\f1\fs20 Sprite
\f0\fs24  class, since those functions use radians instead of degrees, and their positive direction is counter-clockwise. The code to make the ship thrust forward uses an example of such a conversion:\
\

\f1\fs20         if self.keys['up']:\
            angle_radians = -math.radians(self.rotation)\
            force_x = math.cos(angle_radians) * self.thrust * dt\
            force_y = math.sin(angle_radians) * self.thrust * dt\
            self.vx += force_x\
            self.vy += force_y
\f0\fs24 \
\
First, we convert the angle to radians so that 
\f1\fs20 math.cos()
\f0\fs24  and 
\f1\fs20 math.sin()
\f0\fs24  will get the correct values. Then we apply some simple physics to modify the ship's X and Y velocity components.\
\
We now have a complete 
\f1\fs20 Player
\f0\fs24  class. If we add it to the game and tell pyglet that it's an event handler, we should be good to go.\
\

\b Integrating the Player Class\

\b0 The first thing we need to do is make 
\f1\fs20 player_ship
\f0\fs24  an instance of 
\f1\fs20 Player
\f0\fs24 :\
\

\f1\fs20 player_ship = player.Player(x=400, y=300, batch=main_batch)
\f0\fs24 \
\
Now we need to tell pyglet that 
\f1\fs20 player_ship
\f0\fs24  is an event handler. To do that, we need to push it onto the event stack with 
\f1\fs20 game_window.push_handlers()
\f0\fs24 :\
\

\f1\fs20 game_window.push_handlers(player_ship)
\f0\fs24 \
\
That's it! Now you should be able to run the game and move the player with the arrow keys.}